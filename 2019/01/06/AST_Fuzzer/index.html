<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>AST Fuzz —— a New Kind of Fuzzer | 么哈么哈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IntroduceFuzz 测试作为安全领域内的热点话题经久不衰，这主要归功于它在漏洞挖掘领域的卓越表现，fuzz 测试是目前已知的用于挖掘漏洞的最有效手段之一。在与浏览器相关安全的研究中，fuzz 更是占有举足轻重的地位。 As a fruitful vulnerable auto detect method, Fuzz always get a lot of attention. Fuzz i">
<meta property="og:type" content="article">
<meta property="og:title" content="AST Fuzz —— a New Kind of Fuzzer">
<meta property="og:url" content="http://mohamoha.club/2019/01/06/AST_Fuzzer/index.html">
<meta property="og:site_name" content="么哈么哈">
<meta property="og:description" content="IntroduceFuzz 测试作为安全领域内的热点话题经久不衰，这主要归功于它在漏洞挖掘领域的卓越表现，fuzz 测试是目前已知的用于挖掘漏洞的最有效手段之一。在与浏览器相关安全的研究中，fuzz 更是占有举足轻重的地位。 As a fruitful vulnerable auto detect method, Fuzz always get a lot of attention. Fuzz i">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/raw_AST.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/FunctionDeclaration.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/GeneratorDeclaration.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/FlowGraph.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/PathManager.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/ScopeManager.png">
<meta property="og:image" content="http://mohamoha.club/ASTFUZZ/ValueInfo.png">
<meta property="og:updated_time" content="2019-03-03T11:18:14.751Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AST Fuzz —— a New Kind of Fuzzer">
<meta name="twitter:description" content="IntroduceFuzz 测试作为安全领域内的热点话题经久不衰，这主要归功于它在漏洞挖掘领域的卓越表现，fuzz 测试是目前已知的用于挖掘漏洞的最有效手段之一。在与浏览器相关安全的研究中，fuzz 更是占有举足轻重的地位。 As a fruitful vulnerable auto detect method, Fuzz always get a lot of attention. Fuzz i">
<meta name="twitter:image" content="http://mohamoha.club/ASTFUZZ/raw_AST.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">么哈么哈</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Too young, Too simple, Sometime naive</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="https://github.com">github</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mohamoha.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-AST_Fuzzer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/06/AST_Fuzzer/" class="article-date">
  <time datetime="2019-01-05T16:00:00.000Z" itemprop="datePublished">2019-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      AST Fuzz —— a New Kind of Fuzzer
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><p>Fuzz 测试作为安全领域内的热点话题经久不衰，这主要归功于它在漏洞挖掘领域的卓越表现，fuzz 测试是目前已知的用于挖掘漏洞的最有效手段之一。在与浏览器相关安全的研究中，fuzz 更是占有举足轻重的地位。</p>
<p>As a fruitful vulnerable auto detect method, Fuzz always get a lot of attention. Fuzz is one of the most effient way in vulberable digging. In browser security, it also play an important role.</p>
<p>Fuzz 的本质无非是向某个测试对象发送一系列畸形数据来试图引发程序内部发生的一些错误。一般来说 Fuzz 可以分成两种基本形式：生成式和变异式。<br>变异式 Fuzz 是指针对已知的合法输入进行随机或者基于经验的变异，从而产生不可预知的输入。比较典型的工具有 Peach Fuzzer、ProxyFuzz 等。<br>生成式 Fuzz 是指根据已有的经验，规范一个输入的格式，然后基于这个格式生成一系列的输入。比如 SPIKE、Domato 以及一系列浏览器 DOM fuzz。<br>浏览器安全研究中，在以 DOM 对象作为重点研究目标阶段，Fuzz 技术展现了十分优越的性能，短时间内发现了大量 DOM 对象间深层调用所引发的 UAF 漏洞。这其中固然有浏览器 DOM 设计时的缺陷，但是面对如此众多的对象和如此复杂的调用关系，唯有 Fuzz 才可以高效的对其进行测试。</p>
<p>Essentially, Fuzz is a frame that sending a series of data to a target program, and try to trigger internal errors. In general, Fuzz can divided into two types: Generator-FUZZ and Mutator-Fuzz.<br>Mutator-Fuzz try to produce a heristic or random mutation based on a legally seed.  Peach-Fuzzer and Proxy-Fuzzer is two famous mutator fuzz.<br>While Generator-Fuzz try to produce a generate based on given rules. SPIKE, Domato and most of open-source DOM Fuzzer all belong to this cateory.<br>In browser security research, Fuzzer has done fantastic jobs target in DOM. With fuzz, researchers find a huge number of UAF vulnerables in short time. It is true that’s due to the weakness in DOM objects’ top designation, but for a complex system like browser, maybe fuzz is the most effient way to find out flaws.</p>
<p>同时我们也发现了一个问题，即撞洞率太高，一个问题可能会陆续被多个研究者发现，这说明大家所使用的 fuzz 思路是十分接近的。笔者阅读了一些开源的 DOM Fuzzer 源码，发现这些 Fuzzer 虽然具体的形式不同，但是其思想都是通过构造尽可能复杂的语句和 DOM 间对象关系来使目标产生一些异常。这种思路在对 DOM 的研究上已经取得了很大的成功，但是在近两年针对 js 引擎，尤其是 JIT 引擎上，它的表现却不尽如人意。不仅效果很差，而且 Fuzz 产生的样本质量也都普遍不高，可用性很低。分析原因可以看出，旧有的一些 Fuzz 方法大都使用语料库自由组合的方式构造 JS 语句，因而会产生大量无意义的错误代码。而当引擎执行到这些代码时会抛出 <code>RuntimeError</code> 之类的异常，从而提前终止样本。为了使样本可以继续完整执行，Fuzzer 会加入大量的 <code>TryCatch</code> 语句以屏蔽这些异常，进而会影响原本程序的语意。研究 DOM 对象时这种方法自然无可厚非，但是在 JS 引擎，尤其是 JIT 引擎中，<code>TryCatch</code> 会极大的影响引擎的表现，从而使得大部分功能永远无法执行到。其次这种从已有的语料库中进行拼凑的方法需要 Fuzzer 本身对语法的全方位覆盖，而那些语料库覆盖不到的地方则永远不会被访问，这就大大减少了 Fuzz 可以检测到的攻击面，降低了测试效果。</p>
<p>MeanWhile, we also encounter a problem, Clash! The vulnerables we find with our fuzzer can always be noticed by other researchers. It is means we use very similar ideals. After reviewed some open-source DOM-Fuzzer, I realized even though these various specific forms, their core ideas are to make some abnormalities in the target by constructing as many complex statements as possible. This way had achieved great success in DOM , but failed in recent years. Since 2015 most browser researchers are foucing on javascript energe, especially JIT engine. Most of the old fuzzer use the free combination of corpus to construct JS statement, which will generate a lot of meaningless error codes. When the engine execute these codes, it will throw exceptions such as <code>RuntimeError</code>,which will terminates the program early. In order for the sample to continue, Fuzzer will add a large amount of <code>TryCatch</code> statements to block these exceptions. This method is naturally understandable for DOM-Fuzzer, but in the JS engine, especially the JIT engine, <code>TryCatch</code> would greatly affects their performance, so that most functions can never be reseached.  What’s more, this method require the full coverage of the grammar by the Fuzzer itself, and those places the corpus cannot cover will never be accessed, which would greatly decrease the attack surface. </p>
<p>针对目前 JS 引擎 Fuzz 遇到的这种困境，笔者在 18 年 6 月提出了一套全新的 fuzz 方案 ———— AST Fuzz。以 JS 语言解析而成的 AST 树作为媒介进行模糊测试。这种方法不仅可以有效的避免无意义代码的生成，还可以大大提升语法的覆盖率，并且在实际应用过程中还有着意想不到的收获。</p>
<p>In response to this dilemma encountered by the current Fuzz, I proposed a new fuzz idea in June 18th – AST Fuzz! This idea is focus on IR, The AST tree parsed in JS language is used as a medium for fuzzing. This method can not only effectively avoid the generation of meaningless code, but also greatly improve the grammar coverage, and there are unexpected gains in the actual applying.</p>
<a id="more"></a>
<h2 id="Relative-work"><a href="#Relative-work" class="headerlink" title="Relative work"></a>Relative work</h2><p>笔者在提出这个方案后，花费了一个月左右的时间进行了大量的背景分析工作。在调研过程中笔者发现，一些零星的研究者也想到了利用中间语言这种思路进行 fuzz 测试。有的研究者使用这种方法对 PHP-Parser 进行 <a href="https://github.com/MarkRedeman/ast-based-mutations" target="_blank" rel="external">fuzz</a>，有的研究者使用这种方法对 Python 进行 <a href="https://ir.library.oregonstate.edu/downloads/6h440v193" target="_blank" rel="external">fuzz</a>。但是将这种思路应用在浏览器中的只有 <a href="https://github.com/estools/esfuzz" target="_blank" rel="external">ESFuzz</a>。esfuzz 通过不断生成随机的 AST 的方式对 JSC 的 Parser 模块进行测试。可以看到之前的研究大都集中在 Parser 阶段，并没有更进一步，针对 Runtime 或者 JIT 进行更深入的讨论。</p>
<p>After proposing this scheme, I spent one month on a large amount of background analysis. During the researching, I found that some sporadic researchers also use this idea to do fuzzing test. Some use intermediate language to <a href="https://github.com/MarkRedeman/ast-based-mutations" target="_blank" rel="external">fuzz PHP-Parser</a>, Some one use this method to <a href="https://ir.library.oregonstate.edu/downloads/6h440v193" target="_blank" rel="external">test Python</a>. Only <a href="https://github.com/estools/esfuzz" target="_blank" rel="external">ESFuzz</a> is targeting on browser. Esfuzz tests JSC’s Parser module by continuously generating random AST tree and convert it into js code. But all the investigation is concentrated in the Parser moudle, and there is no further step for a more in-depth discussion of Runtime or JIT.</p>
<p>AST 全称抽象语法树，是源代码的抽象语法结构的树状表现形式。抽象语法树(Abstract Syntax Tree ,AST)作为程序的一种中间表示形式,在程序分析等诸多领域有广泛的应用。利用抽象语法树可以方便地实现多种源程序处理工具,比如源程序浏览器、智能编辑器、语言翻译器等，比较为人熟知的 js-beautiful 也是使用 AST 实现的。目前已经有很多比较知名的 AST 处理工具，如 ESTOOLS、BabyLon、Babel 等，FireFox 也对外导出了其解析 AST 的接口：<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="external"><code>Reflect.Parse</code></a>。在 <a href="https://astexplorer.net/" target="_blank" rel="external">AST Explorer</a> 上可以方便的查看源代码与其对应的抽象语法树结构。</p>
<p>Abstract syntax tree (AST), or just syntax tree is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code. The syntax is “abstract” in the sense that it does not represent every detail appearing in the real syntax, but rather just the structural, content-related details. AST is widely used in many areas such as program analysis, source code browser, smart editor and language translator. The well-known js-beautiful is also implemented using AST. There are already many well-known AST processing tools, such as ESTOOLS, BabyLon, Babel, etc. FireFox also exports its interface to parse AST: <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="external"><code>Reflect.Parse</code></a>. One can easily view ast of source code on <a href="https://astexplorer.net/" target="_blank" rel="external">AST Explorer</a> </p>
<p>我们重点关注 JS 语言及其抽象语法树。一段简单的 js 可以表示成如图所示的 AST。</p>
<p>We focus on the JS language and its abstract syntax tree. A simple js can be represented as an AST as shown below.</p>
<p><img src="/ASTFUZZ/raw_AST.png" alt=""></p>
<p>整个代码段是一个 Program 节点，函数的声名，变量的声名分别对应了三个 Declaration 节点。变量 a、b 分别对应了两个 Identifier 节点。而常量 1 对应的是一个 Literal 节点。这样，一段合法的 js 代码就被表示成了一个 AST。同样一个结构完整的 AST 也可以方便的转化成一段在语法上合法的 JS 代码。由于笔者最终的方案选用的是 ESTOOLS 中的 esprima 作为 AST 处理的工具，因此这里将介绍一下 esprima 中 JS 与 AST 节点的对应关系。（不同的 Parse 引擎最终生成的 AST 差异很大，不能通用）。</p>
<p>The code block is a Program node, the declaration of function ,and declarations of varibles corresponds to three Declaration nodes. The variables a and b correspond to two Identifier nodes. The constant 1 corresponds to a Literal node. Thus, a legal js code is represented as an AST. A legal AST can also be easily converted into a syntactically valid JS code. I choose esprima in ESTOOLS as AST processed tools, here I will introduce the correspondence between JS and AST nodes in esprima.The resulting ASTs from different Parse engines are very different and is not universal. </p>
<p>在 esprima 中，js 的 AST 由两种节点构成：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements" target="_blank" rel="external">Statement</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators" target="_blank" rel="external">Expression</a>。 Statement 包括</p>
<p>In esprima, AST is combined with two kind of node: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements" target="_blank" rel="external">Statement</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators" target="_blank" rel="external">Expression</a>. Statement include </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;MetaProperty&quot;、&quot;BlockStatement&quot;、&quot;BreakStatement&quot;、&quot;ContinueStatement&quot;、&quot;DoWhileStatement&quot;、&quot;EmptyStatement&quot;、&quot;ExpressionStatement&quot;、&quot;ForInStatement&quot;、&quot;ForOfStatement&quot;、&quot;FunctionDeclaration&quot;、&quot;IfStatement&quot;、&quot;LabeledStatement&quot;、&quot;ReturnStatement&quot;、&quot;SwitchStatement&quot;、&quot;ThrowStatement&quot;、&quot;TryStatement&quot;、&quot;VariableDeclaration&quot;、&quot;WhileStatement&quot;、&quot;ClassDeclaration&quot;、&quot;WithStatement&quot;</div></pre></td></tr></table></figure>
<p>Expression 包括</p>
<p>Expression include<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;ArrayExpression&quot;、&quot;AwaitExpression&quot;、&quot;AssignmentExpression&quot;、&quot;BinaryExpression&quot;、&quot;CallExpression&quot;、&quot;ConditionalExpression&quot;、&quot;FunctionExpression&quot;、&quot;LogicalExpression&quot;、&quot;MemberExpression&quot;、&quot;NewExpression&quot;、&quot;ObjectExpression&quot;、&quot;SequenceExpression&quot;、&quot;ThisExpression&quot;、&quot;UnaryExpression&quot;、&quot;UpdateExpression&quot;、&quot;YieldExpression&quot;、&quot;ArrowFunctionExpression&quot;、&quot;ClassExpression&quot;、&quot;ArgumentsToken&quot;、&quot;SpreadElement&quot;、&quot;Literal&quot;</div></pre></td></tr></table></figure></p>
<p>每种节点都拥有很多属性对应不同的 JS 表现形式。以 <code>FunctionDeclaration</code> 举例，节点拥有属性 <code>generator</code>，当该属性为 false 时，<code>FunctionDeclaration</code> 用于表示一个普通函数的声名</p>
<p>Each node has a lot of attributes to represent different JS code. For example, <code>FunctionDeclaration</code> has an attribute called <code>generator</code>. When this attribute is false, <code>FunctionDeclaration</code> represents a normal function.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><img src="/ASTFUZZ/FunctionDeclaration.png" alt=""></p>
<p>当 <code>generator</code> 属性为真时，<code>FunctionDeclaration</code> 用于表示一个生成器的声名</p>
<p>When <code>generator</code> equals true, <code>FunctionDeclaration</code> represents a generator function.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p><img src="/ASTFUZZ/GeneratorDeclaration.png" alt=""></p>
<p>Statement 和 Expression 之间互相引用。但是通常来说，Statement 用于表示一条相对独立的 JS 语句，而 Expression 用于表示 js 语句中的表达式。Expression 通常都是可以求值的，而 Statement 则不需要。此外在从 AST 生成 JS 的过程中，esprima 会自动忽略那些其不识别的属性。 </p>
<p>Statement adn Expression can be referenced by each other. In general, Statement is used to represent a relatively independent JS statement, and Expression is used to represent an expression in a js statement. Expressions are usually evaluated, while Statement is not. And esprima will automatically ignores attributes that it does not recognized during the process of generating JS from AST.</p>
<h2 id="AST-FUZZ"><a href="#AST-FUZZ" class="headerlink" title="AST FUZZ"></a>AST FUZZ</h2><p>笔者设计的这套 Fuzz 方案以 AST 为核心，采用变异的方法生成随机样本。整套方案由四部分构成：种子文件预解析，AST 预处理，AST 的变异，样本的生成。下面笔者将详细阐述这四个部分的设计以及实现的相关细节。</p>
<p>This Fuzzer is based on AST and use mutators to generate random samples. The scheme consists of four parts: seeds pre-parsing, AST pre-processing, AST mutation and sample generation. Next page will elaborate on the design of these four parts and the relevant details of the implementation.</p>
<p><img src="/ASTFUZZ/FlowGraph.png" alt=""></p>
<h3 id="First-Part-seed-pre-parsing"><a href="#First-Part-seed-pre-parsing" class="headerlink" title="First Part, seed pre-parsing"></a>First Part, seed pre-parsing</h3><p>首先使用开源工具 esprima 对即将变异的样本文件进行预处理，将 JS 转化为 AST，并最终使用 AST 文件作为 fuzzer 的种子文件。由于这套方案本质上还是一个变异式 Fuzz，因此变异样本的选取对 Fuzz 的最终效果至关重要。</p>
<p>At First, Fuzzer use the open-source tool esprima to preprocess the seed file, parsing the js code into AST tree, and using the AST file as the seed file for the fuzzer. Since this scheme is a mutation Fuzz essentially, the selection of samples is critical to the final result.</p>
<p>在变异样本的选择上，笔者选用之前产生漏洞的原始样本、以及各 JS 引擎提供的 testcase 文件。选取漏洞原始样本作为种子是因为在软件工程领域奉行的 “二八法则”，即 80% 的问题都是由 20% 的模块造成的，特别对于一个大型工程来说，问题常常会集中于某几个模块中。此外，对于漏洞而言，其成因往往复杂难懂，如果漏洞的修补者没有充分了解漏洞的本质成因，补丁常常是可以绕过的，这样的例子屡见不鲜。如笔者曾经发现的存在于 Chakra 中的几个问题。</p>
<p>For this Fuzzer , samples is consisted of vulnerabilities poc and testcases of each JS engine. In software engineer there is a principle named <a href="https://en.wikipedia.org/wiki/Pareto_principle" target="_blank" rel="external"><code>Pareto&#39;s principle</code></a> also known as the 80/20 rule. which means for many events, roughly 80% of the effects come from 20% of the causes. Microsoft noted that by fixing the top 20% of the most-reported bugs, 80% of the related errors and crashes in a given system would be eliminated. Lowell Arthur expressed that “20 percent of the code has 80 percent of the errors. Find them, fix them!”. Especially for vulnerability,  the cause is often complicated and difficult to understand. If the patcher of the vulnerability does not fully understand the nature of the vulnerability, the patch can  be bypassed. This problem is not uncommon. I have found several examples in CharkraCore.</p>
<h4 id="CVE-2017-11840"><a href="#CVE-2017-11840" class="headerlink" title="CVE-2017-11840"></a>CVE-2017-11840</h4><p>这个漏洞最早是由 Lokihart 在17年9月时发现的，漏洞编号为 <code>CVE-2017-11840</code>。样本可以在 Project0 的<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary" target="_blank" rel="external">网站</a>上找到。</p>
<p>This vulnerability was first discovered by Lokihart in September 17th, CVE code is <code>CVE-2017-11840</code>. The poc can be get from the site of <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary" target="_blank" rel="external">Project0</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = [<span class="number">2.3023e-320</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</div><div class="line">        obj.x = <span class="number">1</span>;  <span class="comment">// In the first analysis, BailOnNotObject emitted</span></div><div class="line">        obj = +obj;  <span class="comment">// Change the type</span></div><div class="line">        obj.x = <span class="number">1</span>;  <span class="comment">// Type confusion</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        opt();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">main();</div></pre></td></tr></table></figure>
<p>从漏洞效果上来看，这是一个类型混淆问题。这个问题的本质成因是由于 Chakra 引擎设计时，对循环的优化只进行了固定的两次遍历，这种设计要求在第一次遍历循环时不能对原有指令进行任何修改；但是在编写处理上述语句的代码时，代码编写者并没有考虑这个问题，在第一次遍历时就修改了原有的指令，从而导致最终的分析结果无法传递到每一条指令，最后导致了类型混淆。</p>
<p>This is a type confusion caused by the designation of Chakra. During loop optimization in JIT, Chakra engine will traverse the loop exactly twice, it is not a quite correct design. It requires no modifications can be made to the original instructions during the first traversal of the loop , or there will be something wrong. However, the coder did not realized this issue, and modify the instructions at the first trvaersal. As a result, the final type analysis result cannot be passed to every instructions, which ultimately leads to type confusion.</p>
<p>或许是受到了 <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary" target="_blank" rel="external">issue</a> 中分析的影响，或者是漏洞的修补者没有意识到这个根本问题，最终的补丁代码发生在了类型转化的位置。换而言之，这个补丁可以很轻易的被绕过</p>
<p>Perhaps influenced by the analysis in the <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary" target="_blank" rel="external">issue</a>, or the security researcher of the vulnerability did not realize the fundamental problem. The final patch happened in another place, which means can be bypassed easily.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = <span class="string">"aaaaaa"</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</div><div class="line">        obj.x = <span class="number">1</span>;  <span class="comment">// In the first analysis, BailOnNotObject emitted</span></div><div class="line">        obj = +obj;  <span class="comment">// Change the type</span></div><div class="line">        obj.x = <span class="number">1</span>;  <span class="comment">// Type confusion</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        opt();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">main();</div></pre></td></tr></table></figure>
<p>从上面的例子中可以看出，由于这样那样的原因，曾经的漏洞样本经过轻微的变异就有可能导致新的问题，因此选取他们作为种子文件是一个好的决定。</p>
<p>We can se from the above example, for some reasons the slight variation of the previous vulnerability samples may lead to new problems, so choose them as seed files is a good decision.</p>
<p>而各大引擎的 testcase 则是代码编写者和测试人员针对代码本身的特征编写的测试用例，其对于代码本身而言天然具有良好的覆盖率。以 testcase 作为种子而生成的样本相对于其他种子文件而言可以更好覆盖代码功能。</p>
<p>On the other hand, The testcases of the major engines are test cases written by coders and testers for the characteristics of the code, which naturally have good coverage for the code itself. Samples generated based on testcase would have a better functional coverage relative to other seed files.</p>
<p>选取了原始的素材之后，当然可以直接将其作为种子文件。这里对原始样本进行预处理将其转化为 AST 的目的是为了更好的对变异过程进行控制，以减少那些无意义的变异操作。仍以上例中的 JS 样本为例，我们的 Fuzz 所关心的其实只是 <code>opt</code> 函数以及将其 JIT 时传递的参数，其他的部分并不在我们的考虑范围之内。通过预处理 AST ，在我们不关心的语句节点上打上标记，Fuzzer 识别到这个标记之后就不会对该节点及其子节点进行变异，从而减少了一部分无意义的工作量，将变异范围限定在 <code>opt</code> 函数及其调用的语句上。</p>
<p>After selecting the original material, we can mutate these files directly. But we can have a better control and reduce meaningless mutations, if we use AST tree rather than js code as seed. Take the above JS poc as an example. for the fuzzer ,we only focus on the function <code>opt</code> and its parameters. By pre-processing ,we can mark the statement we do not concern, and Fuzzer will not operate these node. This reduces some of the meaningless workload and limits the scope of the variation to the <code>opt</code> function and related statements.</p>
<h3 id="Second-part-AST-pre-processing"><a href="#Second-part-AST-pre-processing" class="headerlink" title="Second part, AST pre-processing"></a>Second part, AST pre-processing</h3><p>从上文中我们可以知道 AST 由 Statement 和 Expression 两种元素构成，Statement 和 Expression 之间可以相互引用。但是某些 Statement 和 Expression 出现的位置却有着特殊的要求。比如 <code>BreakStatement</code> 只应该出现在循环或者 <code>LabelStatement</code> 中；<code>ArrayPattern</code>只允许出现在参数和赋值语句中。此外，虽然一般而言从 AST 生成的 JS 语句都是符合语法要求的，但是 Fuzz 的样本还应该是符合语意要求的，即不能使 <code>RuntimeError</code> 情况出现的太普遍。这就对 Fuzz 有了更高的要求，如变异所产生的对象节点 <code>Identifier</code> 在多数情况下应该是有意义的，变异产生的函数调用语句不应是明显错误的等等。</p>
<p>From the above we can know that AST consists of two elements, Statement and Expression. Statement and Expression can refer to each other. However, some statements and expressions have special requirements for their location. For example, <code>BreakStatement</code> should only appear in loops or <code>LabelStatement</code>; <code>ArrayPattern</code> is only allowed in parameters and assignment statements. In addition, although the JS statements generated from AST are generally grammatically legal, the Fuzz sample should also be semantically compliant, that is, the <code>RuntimeError</code> situation cannot be made too common. This has higher requirements for Fuzzer. The node <code>Identifier</code> generated by the mutation should be meaningful in most cases. The <code>Callstatement</code> should not be obviously wrong. and so on. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="keyword">var</span> b;</div><div class="line"><span class="keyword">var</span> c = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>如在 <code>1</code> 节点处的 <code>Identifier</code> 变异，只有产生 <code>a</code> 或者 <code>b</code> 才是有意义的。这就要求 Fuzzer 在变异时需要了解当前节点所处的位置和状态信息，获取当前节点可以访问到的对象，以及各个对象在这个节点时的类型。</p>
<p>For example, the mutation in statement <code>var c = 1</code> is only make sence when produce <code>a</code> or <code>b</code>. This requires Fuzzer to know the location and state information of the current node when mutating, to get the objects that the current node can access, and the type of each object at this node.</p>
<h4 id="Node-Location"><a href="#Node-Location" class="headerlink" title="Node Location"></a>Node Location</h4><p>第一个问题比较好解决，在遍历过程中 fuzzer 可以记录下已经走过的节点，或者直接在 AST 节点上记录下每个节点的父节点。当变异过程生成 break 等节点时，判断一下其祖先节点是否符合语法要求。为了保持 AST 结构的完整性，笔者采用 <a href="https://babeljs.io/" target="_blank" rel="external">Babel</a> 的修饰思想实现此功能。为每个 AST 节点创建一个对应的 Path 对象，用于表示这个节点在 AST 中所处的位置等信息。当变异中需要生成 <code>BreakStatement</code>、<code>AwaitStatement</code> 等节点时，Fuzzer 访问当前节点对应的 Path，通过 Path 回溯其祖先节点，检查是否符合语法要求。</p>
<p>This question is easy to solve. During the traversal process, the fuzzer can log the nodes that have passed, and record the parent of each node directly on the AST tree. When the Mutator generates a node such as <code>BreakStatement</code>, Fuzzer will determine whether the ancestor node meets the grammar requirements.In order to maintain the integrity of the AST structure, the Fuzzer uses the idea of ​​<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a> to achieve this function. Fuzzer create a corresponding Path object for each Node, to represent the node location in AST. When the mutator needs to generate nodes such as <code>BreakStatement</code> and <code>AwaitStatement</code>, the Fuzzer ​​accesses the corresponding Path, and backtracks its ancestors through Path to check whether it meets the grammar requirements.</p>
<p><img src="/ASTFUZZ/PathManager.png" alt=""></p>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h4><p>第二个问题也比较好解决。寻找当前节点可访问对象问题可以转化为一个寻找当前节点所处 Scope 问题。节点可以访问当前所在 Scope 以及所有上层 Scope 中所定义的所有对象。具体的做法是，当遇到 <code>Program</code>，<code>Function</code>，<code>Class</code>，<code>Block</code>，<code>for</code> 等本身具有 Scope 的节点时就新建一个 scope 对象更新为当前的 scope ，当遍历到 <code>init</code>，<code>declaration</code> 等节点时就记录下这些节点所生成的 <code>Identifier</code> 信息，并注册到当前的 scope 对象中。为了方便访问，fuzzer 会在节点对应的 Path 中存访一份 scope 对象的引用。变异过程中需要访问可用的对象信息时，直接通过 Path 对象中大的 scope 访问即可。很多开源的 AST 分析工具已经做了这方面的处理，笔者的这套方案为直接修改 <a href="https://github.com/estools/escope" target="_blank" rel="external">ESCOPE</a> 而来。</p>
<p>The second question is also an easy one. The problem finding the current accessible node can be transformed into looking for the current node Scope. The node can access all objects defined in the current Scope and the upper one. Specifically, when we step into self-scoped node like <code>Program</code>，<code>Function</code>，<code>Class</code>，<code>Block</code> and <code>for</code>, we can create a new scope and update it as current scope; when we step into <code>init</code> and <code>declaration</code>, we record the <code>Identifier</code> information, and register into current scope. For easy access ,fuzzer will will store a reference of Scope into corresponding Path. When we need to get the available objects during the mutation process, we can access it directly through the Scope of the Path object. There are many open-source tools can achieve this function, I merged <a href="https://github.com/estools/escope" target="_blank" rel="external">ESCOPE</a> into my fuzzer.</p>
<p><img src="/ASTFUZZ/ScopeManager.png" alt=""></p>
<h4 id="ValueInfo"><a href="#ValueInfo" class="headerlink" title="ValueInfo"></a>ValueInfo</h4><p>在 Scope 的处理中我们可以注意到，同一个 Scope 中定义的所有对象在这个 Scope 的任何位置都可以被访问到。这就意味着，在程序的最开始阶段就可以访问到整个程序中定义的所有全局对象信息。但是在 JS 中，除了 function 之外的其他对象都不允许变量提升，这就需要 Fuzzer 确定节点的类型，防止变异过程中访问那些未定义的变量。</p>
<p>During the processing of Scope we can notice that all objects defined in the same Scope can be accessed anywhere in it. This means all global objects defined in the entire javascript can be accessed at the very beginning of the code. But in js, objects other than function do not allow variable promotion. So Fuzzer need to determine node’s type and revent access to those undefined variables during the mutation. </p>
<p>这就引出了第三个问题，也是是整套方案中最为复杂的一点。Fuzzer 需要知道在某一节点上其可以访问到的所有对象的类型及其可用属性。一方面我们需要避免 <code>f=2; f();</code> 这种明显语意错误的代码出现，即分析出对象在节点位置的类型（<code>Number</code>,<code>String</code>,<code>Function</code>,<code>Object</code>,<code>undefine</code>,<code>null</code>,<code>Symbol</code>）；另一方面我们还需要知道当对象类型不为 Primitive 时，其可能拥有的属性，以便访问之。笔者在这里采用了类似 Chakra 引擎中 <code>Value/ValueInfo</code> 的实现方法。在每个节点处维护一个 ValueMap，ValueMap 中存访该节点可能访问到的所有对象及其类型信息。类型信息是一个索引，除了可以表示对象的类型之外还可以用于在一个全局表中索引该类型的属性。其整体设计如图</p>
<p>This is the third and the most diffcult question. Fuzzer need to know the types and available properties of all objects it can access at a Path. On the one hand, we need to avoid those apparently semantic wrong code like <code>f=2; f();</code> appears, that is to analysis the type of all the avaiable objects (<code>Number</code>,<code>String</code>,<code>Function</code>,<code>Object</code>,<code>undefine</code>,<code>null</code>,<code>Symbol</code>). On the other hand , we need to find out avaiable properties when a object’s type is not Primitive.  Here I use an implementation method similar to <code>Value/ValueInfo</code> in the Chakra engine. Fuzzer manage a ValueMap at every Path, store all the avaiable objects with its type. The type infor stored there is an index that can be used to search detail of the type in a global table. Its overall design is shown below</p>
<p><img src="/ASTFUZZ/ValueInfo.png" alt=""></p>
<p>ValueTable 用于存储所有的类型信息。在遍历 AST 之前，ValueTable 中预先将 JS 的内置函数放入其中，当遍历到类似 <code>ObjectExpression</code>，<code>Function</code>，<code>Class</code> 等会创建新类型的节点时，Fuzzer 会新建一个 Type 对象，存储节点中产生的属性信息，并注册 Type 到 ValueTable 中。当遍历到 <code>a.a = b</code> 之类会导致某对象类型发生变化的节点时，Fuzzer 会从原始 Type 对象中产生一份拷贝作为新的 Type，并将节点可能导致的变化更新到新 Type 中。这样一来就可以在一定程度上获取所有对象的类型和属性信息。</p>
<p>ValueTable is a global table used to store tyep information. Before AST tree traversal, Fuzzer will place builtin types into this ValueTable. When step in node like <code>ObjectExpression</code>，<code>Function</code>，<code>Class</code>, this statement will create a new custom type, Fuzzer will create a type Object as well and register it into the ValueTable. When step in node like <code>a.a = b</code>, this statement can lead to an type change. Fuzzer will duplicate a original type and update the change into the new one. In this way, we can get all the types and attributes to a certain extent.</p>
<p>在变异过程中，如果遇到需要访问对象属性的情况。首先通过 Scope 获取当前节点可以访问的对象集合，接着通过 ValueMap 和 ValueTable 得到对象的类型和属性。</p>
<p>In the mutate part, if we need to access the object properties, first, we can get all avaiable objects through Scope, and then access the type and properties of the object through ValueMap and ValueTable.</p>
<p>这部分设计几经修改仍然没有一个比较满意的方案。现在的版本是目前阶段笔者所能想到的最优设计，但是仍然存在着很大的改进空间。</p>
<p>This part has been changed mant times and still does not have a satisfactory solution. Current version is the optimal design that I can think of at the current stage, but there is still much room for improvement.</p>
<h3 id="Third-part-AST-Mutation"><a href="#Third-part-AST-Mutation" class="headerlink" title="Third part, AST Mutation"></a>Third part, AST Mutation</h3><p>经过预处理阶段的分析，Fuzzer 可以得到原始样本中所有节点的状态信息。根据状态信息就可以开始进行变异操作了。</p>
<p>After pre-processing ,Fuzzer can get all the need information, and now we can start mutation.</p>
<p>节点可能产生的变异大体上可以分成四类。一是简单变异，即仅对诸如 <code>operator</code>，<code>Identifier</code>，<code>Literal</code> 等非控制节点进行同类型变异。将 <code>operator</code> 替换为其他的 <code>operator</code>，将 <code>Identifier</code> 和 <code>Literal</code> 在合法范围内替换为 <code>Literal</code> 或 <code>Identifier</code>。这种变异不会对 AST 的整体结构产生影响，相对来说更简单。二是节点的扩展，即在保留原始节点的基础上增加新的节点，将原始节点作为新节点的某一子节点。三是节点的删除，在合理范围内直接删除某些节点。四是节点的替换，将节点进行同类型替换，Statement 替换为 Statement，Expression 替换为 Expression。出于变异的方便，笔者设计采用父节点控制的方法进行操作。在变异操作进入某一结点时，将该节点作为父节点，随机选取一种变异方式对节点的子节点进行变异。这种方法不仅可以方便的对变异过程进行控制，还可以获取变异之后整个节点的新状态，这一点尤为重要。</p>
<p>Mutation can be divied into four types. First one, simple mutation, Only replace those native data node like <code>operator</code>,<code>Identifier</code> and <code>Literal</code>. <code>operator</code> can only changed into <code>operator</code>, and <code>Identifier</code>,<code>Literal</code> can only be changed into <code>Identifier</code>,<code>Literal</code>. This type of mutation will not change the struct of AST tree. Second one, extend mutation.  Extending a new node based on the original node, and using the original node as a child node of the new node. Third one, deletion. directly deleting certain nodes within a reasonable range. Fouth one, Replacement. Replace the node with the same type, replace the Statement with a Statement, and replace Expression with Expression. For the convenience of variation, here Fuzzer use the parent-controlled method to do the mutation. When the mutator enter a node, the node is used as a parent node, and a mutation method is randomly selected to mutate the child nodes. This method is not only convenient for controlling the mutation process, but also for obtaining the new state of the entire node after the mutation, which is especially important.</p>
<p>在一个节点变异完成之后，一个重要的步骤是通知 AST 中其他尚未被变异的节点此次变异所带来的影响。这里笔者通过 Path 对象中的 successor 属性实现。successor 属性指向 AST 中节点顺序访问序列的下一个。通过 successor 可以顺序通知到所有的后续节点，更新其 scope 及 valueMap 状态，以便之后的变异操作使用。</p>
<p>After a mutation is completed, next important step is to notify the rest part of AST. Here I used successor attribute of Path object to do this. successor is pointing to next node in the sequence. Fuzzer can get all the subsequent part of AST throuth successor, and their scope and valueMap status can be updated for subsequent mutation operations.</p>
<h3 id="Fouth-part-Sample-generator"><a href="#Fouth-part-Sample-generator" class="headerlink" title="Fouth part, Sample generator"></a>Fouth part, Sample generator</h3><p>AST 变异完成之后，将 AST 转化回 JS。现有的很多工具可以实现这一工作。笔者继续选用 esprima 来完成</p>
<p>After the AST mutation is complete, AST need be converted back to JS. I use esprima.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>下面的示例图是笔者最初的设计。整套方案的核心思想就是利用 AST 可以灵活转换的性质生成更可靠的 js 代码。</p>
<p>The diagram below is my original design. The core idea of this whole solution is to use the AST’s flexible transformation to generate more reliable js code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Mutation fuzz </div><div class="line"></div><div class="line">	AST  -&gt; Shadow -&gt; mutated AST -&gt; js code </div><div class="line"></div><div class="line">						     mutated AST</div><div class="line">		 			/              |               \</div><div class="line">	1.statement mutate   2. expression mutate   3. value mutate</div><div class="line">	</div><div class="line">	1. Traverse the AST to mark node that should be mutated, and record the object of each scope</div><div class="line">	the information stored in another tree named shadow</div><div class="line">	</div><div class="line">	2. Traverse the Shadow ,mutate the marked node to</div></pre></td></tr></table></figure>
<p>这其实是一个比较直观的思路，但是在笔者提出之前，尚未发现任何公开的使用类似思路对浏览器引擎进行模糊测试的方法出现。应用这套方案之后也的确发现了很多以前不曾发现的问题，在很大程度上提升了 fuzz 的效率。</p>
<p>I think it is a relatively straightforward idea, but I have not found any publicly used methods to fuzz the browser engine using similar ideas before. After applying this solution, it has indeed found many problems that have not been discovered before, which greatly improved the efficiency of fuzz. </p>
<p>但是出于一些原因，笔者无法继续这套引擎的开发。于是打算分享给大众，为浏览器研究者们提供一些新的思路。整套引擎的源码在笔者整理过后会放到 GitHub 上。由于开发的时间比较短，目前整套引擎还处于一个很不成熟的阶段，比如对象类型的分析还存在很大的问题，变异部分的代码更是只有一个简单的实现。</p>
<p>For some reason, I can’t continue the development of this engine. So I prepare to share it with the public and provide some new ideas for other browser researchers. The source code of the entire engine will be published on GitHub after compiled. Due to the short development time, the current set of engines is still in a very immature stage. For example, the analysis of object types still has a big problem, and the code of the mutation part has only a simple implementation.</p>
<p>不管怎样，还是希望看到这篇文章的研究者们可以肯定我所做的微小的工作。</p>
<p>Anyway, hope the researchers who see this article can be sure of the tiny work I have done.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://github.com/MarkRedeman/ast-based-mutations" target="_blank" rel="external">https://github.com/MarkRedeman/ast-based-mutations</a><br>[2] <a href="https://ir.library.oregonstate.edu/downloads/6h440v193" target="_blank" rel="external">https://ir.library.oregonstate.edu/downloads/6h440v193</a><br>[3] <a href="https://github.com/estools/esfuzz" target="_blank" rel="external">https://github.com/estools/esfuzz</a><br>[4] <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Parser_API</a><br>[5] <a href="https://astexplorer.net/" target="_blank" rel="external">https://astexplorer.net/</a><br>[6] <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary" target="_blank" rel="external">https://bugs.chromium.org/p/project-zero/issues/detail?id=1365&amp;can=1&amp;q=CVE-2017-11840&amp;colspec=ID%20Status%20Restrict%20Reported%20Vendor%20Product%20Finder%20Summary</a><br>[7] <a href="https://babeljs.io/" target="_blank" rel="external">https://babeljs.io/</a><br>[8] <a href="https://github.com/estools/escope" target="_blank" rel="external">https://github.com/estools/escope</a></p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h5 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(pathManager, node, parent, pred, scope)&#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * reference to the current node</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.node = node;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * reference to the parent node </span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="comment">//this.parent = parent;</span></div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * reference to the predcessor of current node</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.predcessor = pred;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * reference to the successor of current node</span></div><div class="line"><span class="comment">         * node to notify</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.successor = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * current scope of the current node</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.scope = scope;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * a map record the identifer and it's valueInfo at current node</span></div><div class="line"><span class="comment">         * &lt;id.name, valueInfo&gt;</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.valueMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param &#123;Identifer&#125; id </span></div><div class="line"><span class="comment">     * @param &#123;ValueInfo&#125; value </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    updateValue(id,value)&#123;</div><div class="line">        <span class="keyword">var</span> valueInfo;</div><div class="line">        <span class="keyword">if</span>(valueInfo = <span class="keyword">this</span>.valueMap.get(id))&#123;</div><div class="line">            valueInfo.update(value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.valueMap.set(id,value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * merge the valueMap into path</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    update(_path)&#123;</div><div class="line">        <span class="keyword">if</span>(_path)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> [key,value] <span class="keyword">of</span> _path.valueMap)&#123;</div><div class="line">                <span class="keyword">var</span> valueInfo;</div><div class="line">                <span class="keyword">if</span> (valueInfo = <span class="keyword">this</span>.valueMap.get(key))&#123;</div><div class="line">                    valueInfo.update(value);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    valueInfo = <span class="keyword">new</span> ValueInfo();</div><div class="line">                    <span class="keyword">if</span>(!value)</div><div class="line">                        <span class="built_in">console</span>.log(_path);</div><div class="line">                    valueInfo.update(value);</div><div class="line">                    <span class="keyword">this</span>.valueMap.set(key,valueInfo);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * replace the value of src with dst in _path</span></div><div class="line"><span class="comment">     * @param &#123;Path&#125; _path </span></div><div class="line"><span class="comment">     * @param &#123;key&#125; src </span></div><div class="line"><span class="comment">     * @param &#123;key&#125; dst </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    replaceValue(_path, src, dst)&#123;</div><div class="line">        <span class="keyword">if</span>(!_path.valueMap.get(dst))&#123;</div><div class="line">            <span class="keyword">let</span> valueinfo = <span class="keyword">new</span> ValueInfo();</div><div class="line">            <span class="keyword">this</span>.valueMap.set(src,valueinfo);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">this</span>.valueMap.set(src,_path.valueMap.get(dst));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @param &#123;key&#125; src </span></div><div class="line"><span class="comment">     * @param &#123;ValueInfo&#125; value </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    setValue(src, value)&#123;</div><div class="line">        <span class="keyword">let</span> v = value;</div><div class="line">        <span class="keyword">if</span>(!v)&#123;</div><div class="line">            v = <span class="keyword">new</span> ValueInfo();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.valueMap.set(src, v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __exit(pathManager)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ValueInfo-1"><a href="#ValueInfo-1" class="headerlink" title="ValueInfo"></a>ValueInfo</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueInfo</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(type = 0x0000)&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 0x0000 undefine</span></div><div class="line"><span class="comment">         * 0x0001 null</span></div><div class="line"><span class="comment">         * 0x0002 number</span></div><div class="line"><span class="comment">         * 0x0004 string</span></div><div class="line"><span class="comment">         * 0x0008 boolean</span></div><div class="line"><span class="comment">         * 0x0010 object</span></div><div class="line"><span class="comment">         * 0x0020 function</span></div><div class="line"><span class="comment">         * 0x0040 class</span></div><div class="line"><span class="comment">         * 0x0080 symbol</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.__type = type;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * type index in valueTable </span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.__symIndex = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * A set record the property of current Valueinfo</span></div><div class="line"><span class="comment">         * &lt;id&gt; </span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.__props = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * A set record the method of current ValueInfo</span></div><div class="line"><span class="comment">         * &lt;id&gt;</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.__methods = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * if the type is a func, descript the number of param and so on</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">this</span>.__desc = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updateType(type)&#123;</div><div class="line">        <span class="keyword">this</span>.__type = <span class="keyword">this</span>.__type| type; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * merge the props into current props</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    updateProp(props)&#123;</div><div class="line">        <span class="keyword">if</span>(props)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">of</span> props.values())&#123;</div><div class="line">            <span class="keyword">this</span>.__props.add(prop);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * merge the method into current method</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    updateMethod(methods)&#123;</div><div class="line">        <span class="keyword">if</span>(methods)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> method <span class="keyword">of</span> methods.values())&#123;</div><div class="line">            <span class="keyword">this</span>.__methods.add(method);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Merge the valueInfo into current Info</span></div><div class="line"><span class="comment">     * @param &#123;ValueInfo&#125; valueInfo </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    update(valueInfo)&#123;</div><div class="line">        <span class="keyword">this</span>.updateType(valueInfo.__type);</div><div class="line">        <span class="keyword">this</span>.updateProp(valueInfo.__props);</div><div class="line">        <span class="keyword">this</span>.updateMethod(valueInfo.__methods);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="PathManager"><a href="#PathManager" class="headerlink" title="PathManager"></a>PathManager</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathManager</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options)&#123;</div><div class="line">        <span class="keyword">this</span>.__nodeToPath = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">        <span class="keyword">this</span>.__currentAncestor = <span class="literal">null</span>;  <span class="comment">// pred node in mutate exe</span></div><div class="line">        <span class="keyword">this</span>.__currentParent = <span class="literal">null</span>;   <span class="comment">// parent node </span></div><div class="line">        <span class="keyword">this</span>.__currentPath = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>.__options = options;</div><div class="line">        <span class="keyword">this</span>.__valueMap = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">// do as the valueMap in chakra</span></div><div class="line">        <span class="keyword">this</span>.__valueTable = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">        <span class="keyword">this</span>.__initialize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __initialize()&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * init Object</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">var</span> arrayTypeInfo = <span class="keyword">new</span> ValueInfo(<span class="number">0x0010</span>);</div><div class="line">        <span class="keyword">this</span>.__valueTable.set(<span class="string">"arrayType"</span>,arrayTypeInfo);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * init Array</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">var</span> arrayTypeInfo = <span class="keyword">new</span> ValueInfo(<span class="number">0x0010</span>);</div><div class="line">        <span class="keyword">this</span>.__valueTable.set(<span class="string">"arrayType"</span>,arrayTypeInfo);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * Init Function</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">var</span> funcTypeInfo = <span class="keyword">new</span> ValueInfo(<span class="number">0x0010</span>);</div><div class="line">        <span class="keyword">this</span>.__valueTable.set(<span class="string">"funcType"</span>,funcTypeInfo);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * Init Class</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">var</span> classTypeInfo = <span class="keyword">new</span> ValueInfo(<span class="number">0x0010</span>);</div><div class="line">        <span class="keyword">this</span>.__valueTable.set(<span class="string">"classType"</span>,classTypeInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __get(node) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.__nodeToPath.get(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    acquire(node, inner) &#123;</div><div class="line">        <span class="keyword">var</span> path, i, iz;</div><div class="line"></div><div class="line">        path = <span class="keyword">this</span>.__get(node);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">      一步</span></div><div class="line"><span class="comment">      TODO : currentAncestor is not the real ancestor</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    __stepPath(path)&#123;</div><div class="line">        <span class="comment">// setup the path info</span></div><div class="line">        <span class="keyword">let</span> node = path.node;</div><div class="line">        <span class="keyword">let</span> predPath = <span class="keyword">this</span>.acquire(path.predcessor);</div><div class="line">        <span class="keyword">if</span>(predPath)&#123;</div><div class="line">            predPath.successor = node;</div><div class="line">            path.valueMap = <span class="keyword">new</span> <span class="built_in">Map</span>(predPath.valueMap);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.__nodeToPath.set(node, path);</div><div class="line">        <span class="keyword">this</span>.__currentAncestor = <span class="keyword">this</span>.__currentPath;</div><div class="line">        <span class="keyword">this</span>.__currentPath = path;</div><div class="line">        <span class="keyword">return</span> path;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __stepOut(path)&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __stepExpression(node, scope, parent, pred)&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">this</span>.__stepPath(<span class="keyword">new</span> Path(<span class="keyword">this</span>, node, parent, pred, scope));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __stepStatement(node, scope, parent, pred)&#123;</div><div class="line">        <span class="keyword">this</span>.__stepPath(<span class="keyword">new</span> Path(<span class="keyword">this</span>, node, parent, pred, scope));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mohamoha.club/2019/01/06/AST_Fuzzer/" data-id="ckhsv3p10000jckuu1of7fmue" class="article-share-link">Share</a>
      
        <a href="http://mohamoha.club/2019/01/06/AST_Fuzzer/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/14/Link_file_and_sdcard/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Link File and Sdcard in Android
        
      </div>
    </a>
  
  
    <a href="/2018/11/24/Babel_HelloWorld/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Babel HelloWorld</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/16/chrome_dead_lock/">解决 Chrome 启动进程卡顿问题</a>
          </li>
        
          <li>
            <a href="/2019/09/14/Link_file_and_sdcard/">Link File and Sdcard in Android</a>
          </li>
        
          <li>
            <a href="/2019/01/06/AST_Fuzzer/">AST Fuzz —— a New Kind of Fuzzer</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Babel_HelloWorld/">Babel HelloWorld</a>
          </li>
        
          <li>
            <a href="/2018/09/07/EVM_Simulator/">EVM Simulator</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget tag">
    <h3 class="title">Site Links</h3>
    <ul class="entry">
    <li><a href="http://5alt.me" title="5alt">5alt's Blog</a></li>
    </ul>
</div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 mohaplus<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="https://github.com" class="mobile-nav-link">github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'mohamoha';
  
  var disqus_url = 'http://mohamoha.club/2019/01/06/AST_Fuzzer/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>