<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Bypass CFG Through MRDATA | 么哈么哈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf 这是 Alex 大神的一篇演讲，介绍了一种新的绕过 CFG 的思路 MRDATA从 Win8.1 开始微软为 CFG 的 bitmap 添加了保护机制，将 bitmap 指针等一系列全局变量放置于文件的 .mrdata 区段，这是一个新的 PE 区段，用于保">
<meta property="og:type" content="article">
<meta property="og:title" content="Bypass CFG Through MRDATA">
<meta property="og:url" content="http://mohamoha.club/2017/12/23/Bypass_CFG_Through_MRDATA/index.html">
<meta property="og:site_name" content="么哈么哈">
<meta property="og:description" content="http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf 这是 Alex 大神的一篇演讲，介绍了一种新的绕过 CFG 的思路 MRDATA从 Win8.1 开始微软为 CFG 的 bitmap 添加了保护机制，将 bitmap 指针等一系列全局变量放置于文件的 .mrdata 区段，这是一个新的 PE 区段，用于保">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-01-13T10:21:28.459Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bypass CFG Through MRDATA">
<meta name="twitter:description" content="http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf 这是 Alex 大神的一篇演讲，介绍了一种新的绕过 CFG 的思路 MRDATA从 Win8.1 开始微软为 CFG 的 bitmap 添加了保护机制，将 bitmap 指针等一系列全局变量放置于文件的 .mrdata 区段，这是一个新的 PE 区段，用于保">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">么哈么哈</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Too young, Too simple, Sometime naive</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="https://github.com">github</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mohamoha.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Bypass_CFG_Through_MRDATA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/23/Bypass_CFG_Through_MRDATA/" class="article-date">
  <time datetime="2017-12-22T16:00:00.000Z" itemprop="datePublished">2017-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Bypass CFG Through MRDATA
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf" target="_blank" rel="noopener">http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf</a></p>
<p>这是 Alex 大神的一篇演讲，介绍了一种新的绕过 CFG 的思路</p>
<h2 id="MRDATA"><a href="#MRDATA" class="headerlink" title="MRDATA"></a>MRDATA</h2><p>从 Win8.1 开始微软为 CFG 的 bitmap 添加了保护机制，将 bitmap 指针等一系列全局变量放置于文件的 <code>.mrdata</code> 区段，这是一个新的 PE 区段，用于保存那些易变的只读数据。</p>
<p>这个区段在模块加载时被标记为 PAGE_READONLY ，理论上无法被修改。</p>
<p>但是某些时候 ntdll 需要去修改 <code>.mrdata</code> 区段中的某些数据。为此Windows 提供了一个新的 API : <code>LdrProtectMrdata( bProtect )</code>函数用于设置 <code>.mrdata</code>区段是否开启保护 ，参数传入 0 表示 unprotect，传入 1 表示 protect。</p>
<p>很明显在模块加载和卸载时都会调用这个函数来设置一些数据，然而有些函数在运行时也会调用这个 API。</p>
<p>例如<code>SetProtectedPolicy</code> 和 <code>GetProtectedPolicy</code>就会用到它。这两个函数用于设置和获取进程的保护策略，这些策略保存在通过 <code>LdrMrdataHeap</code> 分配的内存中，即策略处于 <code>.mrdata</code> 区段</p>
<a id="more"></a>
<p>还有许多函数会调用，这里简单列出一些，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime Calls</span></span><br><span class="line">RtlAddFunctionTable</span><br><span class="line">RtlAddGrowableFunctionTable</span><br><span class="line">RtlDeleteFunctionTable</span><br><span class="line">RtlDeleteGrowableFunctionTable</span><br><span class="line">RtlInsertInvertedFunctionTable</span><br><span class="line">RtlInstallFunctionTableCallback</span><br><span class="line">RtlSetProtectedPolicy</span><br><span class="line">RtlpAddVectoredHandler</span><br><span class="line">RtlpCallVectoredHandlers</span><br><span class="line">RtlpRemoveVectoredHandler</span><br><span class="line">RtlxRemoveInvertedFunctionTable</span><br></pre></td></tr></table></figure></p>
<h2 id="Bypassing-CFG-with-MRDATA"><a href="#Bypassing-CFG-with-MRDATA" class="headerlink" title="Bypassing CFG with MRDATA"></a>Bypassing CFG with MRDATA</h2><p>Edge JIT 时会有大量针对 Growable Function Table 的操作，这些操作会多次调用 <code>LdrProtectMrdata</code> 设置<br><code>.mrdata</code> 区段的属性。如果攻击者多次触发 JIT 就会导致 <code>.mrdata</code> 区段频繁的改变属性</p>
<p>显然这种 Growable Function Table 是一种共享资源，微软通过 <a href="https://msdn.microsoft.com/zh-cn/library/br244843.aspx" target="_blank" rel="noopener">SRWLock</a> 来对 Table 进行管理，对 Lock 进行了 ACquire 操作之后才能对 Table 进行修改。 </p>
<h3 id="SRWLock"><a href="#SRWLock" class="headerlink" title="SRWLock"></a>SRWLock</h3><p>SRWLock 是一种轻量级的读写锁，其本质就是一个指针，它标识信息的方式如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">______________________________|________________________________</span><br><span class="line">31                           16                       4 3 2 1 0</span><br></pre></td></tr></table></figure></p>
<p>指针的低四位被用作四个不同的标识</p>
<ul>
<li>owned 拥有位   0 位为1表明有线程正在读\写资源</li>
<li>CONTENDED 写入位   1 位为1表明有一个或多个线程在等待独占资源，也即当前有线程正在独占资源</li>
<li>SHARED 读取位   2 位为1表明有一个或多个线程在等待读取资源</li>
<li>CONTENTION 结构位   3 位为1表明有一个线程正在获取 WAITBLOCK 结构指针</li>
</ul>
<p>指针的高 28 位为地址位。当没有线程在请求独占资源时，其用来表示正在共享读资源的线程个数；当在同时有一个以上线程在等待资源的时候，它会被用做指向一个结构体链表，其指向的地址以 0x10 对齐。在有其他线程在读\写资源的时候,一个线程调用AcquireSRWLockExclusive或者AcquireSRWLockShared 操作会将一个在栈上构建的结构体挂入SRWLock 所指向的链表，这样每个将要读/写资源的线程都会在栈上构建这么一个结构体，并将结构体挂入链表中。</p>
<p>该结构体的定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTLP_SRWLOCK_WAITBLOCK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    LONG SharedCount; <span class="comment">//有多少线程 在等待读取</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTLP_SRWLOCK_WAITBLOCK</span> *<span class="title">Last</span>;</span>    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTLP_SRWLOCK_WAITBLOCK</span> *<span class="title">Next</span>;</span>   <span class="comment">//链表节指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        LONG Wake;                                   <span class="comment">//非0表示可以被唤醒，0表示继续睡眠</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            PRTLP_SRWLOCK_SHARED_WAKE SharedWakeChain;   <span class="comment">//需要被唤醒的读资源线程链表</span></span><br><span class="line">            PRTLP_SRWLOCK_SHARED_WAKE LastSharedWake;    <span class="comment">//上一个被唤醒的读资源线程</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    BOOLEAN Exclusive;                         <span class="comment">//1表示该结构体对象由写资源线程构建在栈上，0表示结构体由读资源线程构建在栈上</span></span><br><span class="line">&#125; <span class="keyword">volatile</span> RTLP_SRWLOCK_WAITBLOCK, *PRTLP_SRWLOCK_WAITBLOCK;</span><br></pre></td></tr></table></figure></p>
<p>下面是单项链表的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTLP_SRWLOCK_SHARED_WAKE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LONG Wake;   <span class="comment">//唤醒标志，非0唤醒，0睡眠</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTLP_SRWLOCK_SHARED_WAKE</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125; <span class="keyword">volatile</span> RTLP_SRWLOCK_SHARED_WAKE, *PRTLP_SRWLOCK_SHARED_WAKE;</span><br></pre></td></tr></table></figure></p>
<p>由于写操作一定是独占的，因此这里重点关注 Exclusive 独占型请求。<br>AcquireSRWLockExclusive 操作对应函数 RtlAcquireSRWLockExclusive，其源码如下，注释中对代码的流程进行了说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">RtlAcquireSRWLockExclusive(IN OUT PRTL_SRWLOCK SRWLock)</span><br><span class="line">&#123;</span><br><span class="line">    __ALIGNED(<span class="number">16</span>) RTLP_SRWLOCK_WAITBLOCK StackWaitBlock;   <span class="comment">// 首先在栈中分配 RTLP_SRWLOCK_WAITBLOCK 结构</span></span><br><span class="line">    PRTLP_SRWLOCK_WAITBLOCK First, Last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InterlockedBitTestAndSetPointer(&amp;SRWLock-&gt;Ptr, RTL_SRWLOCK_OWNED_BIT))   <span class="comment">// 如果有其他线程在访问资源则进入下面的循环，否则将 owned 标志位置一</span></span><br><span class="line">    &#123;</span><br><span class="line">        LONG_PTR CurrentValue, NewValue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CurrentValue = *(<span class="keyword">volatile</span> LONG_PTR *)&amp;SRWLock-&gt;Ptr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_SHARED)       <span class="comment">// 如果有线程在读资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* A shared lock is being held right now. We need to add a wait block! */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_CONTENDED)     </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">goto</span> AddWaitBlock;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                          <span class="comment">// 如果有线程在读资源且没有其他线程在等待写资源，则表明当前没有等待的线程，</span></span><br><span class="line">                &#123;                                             <span class="comment">// 将 RTLP_SRWLOCK_WAITBLOCK 作为第一个节点挂入链表</span></span><br><span class="line">                    StackWaitBlock.Exclusive = TRUE;          <span class="comment">// 独占标志位</span></span><br><span class="line">                    StackWaitBlock.SharedCount = CurrentValue &gt;&gt; RTL_SRWLOCK_BITS;      <span class="comment">// 此时的地址位用来保存共享读线程的个数</span></span><br><span class="line">                    StackWaitBlock.Next = <span class="literal">NULL</span>;</span><br><span class="line">                    StackWaitBlock.Last = &amp;StackWaitBlock;</span><br><span class="line">                    StackWaitBlock.Wake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    ASSERT_SRW_WAITBLOCK(&amp;StackWaitBlock);</span><br><span class="line">                    </span><br><span class="line">                    NewValue = (ULONG_PTR)&amp;StackWaitBlock | RTL_SRWLOCK_SHARED | RTL_SRWLOCK_CONTENDED | RTL_SRWLOCK_OWNED;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (InterlockedCompareExchangePointer(&amp;SRWLock-&gt;Ptr,</span><br><span class="line">                                                          (PVOID)NewValue,</span><br><span class="line">                                                          (PVOID)CurrentValue) == (PVOID)CurrentValue)  <span class="comment">// 将 SRWLOCK-&gt;ptr 替换为新值</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        RtlpAcquireSRWLockExclusiveWait(SRWLock,</span><br><span class="line">                                                        &amp;StackWaitBlock);    <span class="comment">// 线程进入等待</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Successfully acquired the exclusive lock */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_OWNED)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_CONTENDED)  <span class="comment">// 如果有线程在等待写资源则将 RTLP_SRWLOCK_WAITBLOCK 挂入链表中</span></span><br><span class="line">                    &#123;</span><br><span class="line">AddWaitBlock:</span><br><span class="line">                        StackWaitBlock.Exclusive = TRUE;</span><br><span class="line">                        StackWaitBlock.SharedCount = <span class="number">0</span>;      </span><br><span class="line">                        StackWaitBlock.Next = <span class="literal">NULL</span>;</span><br><span class="line">                        StackWaitBlock.Last = &amp;StackWaitBlock;</span><br><span class="line">                        StackWaitBlock.Wake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        ASSERT_SRW_WAITBLOCK(&amp;StackWaitBlock);</span><br><span class="line"></span><br><span class="line">                        First = RtlpAcquireWaitBlockLock(SRWLock);    <span class="comment">// 根据28位的指针去掉标志位，获取指向的链表表头，</span></span><br><span class="line">                        <span class="keyword">if</span> (First != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Last = First-&gt;Last;                       <span class="comment">// 将 RTLP_SRWLOCK_WAITBLOCK 插入双向链表的尾部 </span></span><br><span class="line">                            Last-&gt;Next = &amp;StackWaitBlock;</span><br><span class="line">                            First-&gt;Last = &amp;StackWaitBlock;</span><br><span class="line"></span><br><span class="line">                            RtlpReleaseWaitBlockLock(SRWLock);</span><br><span class="line"></span><br><span class="line">                            RtlpAcquireSRWLockExclusiveWait(SRWLock,      <span class="comment">// 进入线程等待</span></span><br><span class="line">                                                            &amp;StackWaitBlock);  </span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* Successfully acquired the exclusive lock */</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>                                                <span class="comment">// 当前即没有线程在(等待)读资源也没有线程在等待写资源 </span></span><br><span class="line">                                                                        <span class="comment">// 将 RTLP_SRWLOCK_WAITBLOCK 作为第一个节点挂入链表</span></span><br><span class="line">                                                                        <span class="comment">// 即只有一个写资源线程的情况</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        StackWaitBlock.Exclusive = TRUE;</span><br><span class="line">                        StackWaitBlock.SharedCount = <span class="number">0</span>;</span><br><span class="line">                        StackWaitBlock.Next = <span class="literal">NULL</span>;</span><br><span class="line">                        StackWaitBlock.Last = &amp;StackWaitBlock;</span><br><span class="line">                        StackWaitBlock.Wake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        ASSERT_SRW_WAITBLOCK(&amp;StackWaitBlock);</span><br><span class="line"></span><br><span class="line">                        NewValue = (ULONG_PTR)&amp;StackWaitBlock | RTL_SRWLOCK_OWNED | RTL_SRWLOCK_CONTENDED;</span><br><span class="line">                        <span class="keyword">if</span> (InterlockedCompareExchangePointer(&amp;SRWLock-&gt;Ptr,</span><br><span class="line">                                                              (PVOID)NewValue,</span><br><span class="line">                                                              (PVOID)CurrentValue) == (PVOID)CurrentValue)</span><br><span class="line">                        &#123;</span><br><span class="line">                            RtlpAcquireSRWLockExclusiveWait(SRWLock,         <span class="comment">// 进入线程等待</span></span><br><span class="line">                                                            &amp;StackWaitBlock);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* Successfully acquired the exclusive lock */</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>                                              <span class="comment">// 写资源线程请求一个空闲的 SRWLock</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!InterlockedBitTestAndSetPointer(&amp;SRWLock-&gt;Ptr,</span><br><span class="line">                                                         RTL_SRWLOCK_OWNED_BIT))    </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* We managed to get hold of a simple exclusive lock! */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            YieldProcessor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NTAPI</span><br><span class="line">RtlpAcquireSRWLockExclusiveWait(IN OUT PRTL_SRWLOCK SRWLock, IN PRTLP_SRWLOCK_WAITBLOCK WaitBlock)</span><br><span class="line">&#123;</span><br><span class="line">    LONG_PTR CurrentValue;</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        CurrentValue = (volatile LONG_PTR *)&amp;SRWLock-&gt;Ptr;</span><br><span class="line">        if (!(CurrentValue &amp; RTL_SRWLOCK_SHARED))</span><br><span class="line">        &#123;</span><br><span class="line">            if (CurrentValue &amp; RTL_SRWLOCK_CONTENDED)</span><br><span class="line">            &#123;</span><br><span class="line">                if (WaitBlock-&gt;Wake != 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        YieldProcessor();                         //只有在没有线程在读取，没有其他生产线程在独占，或者独占的线程将该线程的WAKE标志设为非0，时退出死循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RtlAcquireSRWLockExclusive 函数的功能总结起来</p>
<ol>
<li>当有线程还在读取资源，当前没有写资源线程在等待， 那么挂入 WAITBLOCK，设置标志 （读取  独占 拥有），进入等待，读取线程全部Release时 线程等待结束，以独占模式访问资源</li>
<li>有其他生产线程在等待时，将 WAITBLOCK 挂入SRWLock指针所指向链表的末尾，进入等待，在前面所有已挂入的等待都Release时，线程才结束等待 以独占模式访问资源。</li>
<li>如果有线程在写资源，但是没有其他线程在等待的，那么挂入 WAITBLOCK，设置标志 （独占 拥有），进入等待，读取线程全部Release时 线程等待结束，以独占模式访问资源</li>
</ol>
<p>与之相对的 ReleaseSRWLockExclusive 的代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">RtlReleaseSRWLockExclusive(IN OUT PRTL_SRWLOCK SRWLock)</span><br><span class="line">&#123;</span><br><span class="line">    LONG_PTR CurrentValue, NewValue;</span><br><span class="line">    PRTLP_SRWLOCK_WAITBLOCK WaitBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CurrentValue = *(<span class="keyword">volatile</span> LONG_PTR *)&amp;SRWLock-&gt;Ptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(CurrentValue &amp; RTL_SRWLOCK_OWNED))</span><br><span class="line">        &#123;</span><br><span class="line">            RtlRaiseStatus(STATUS_RESOURCE_NOT_OWNED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(CurrentValue &amp; RTL_SRWLOCK_SHARED))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_CONTENDED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* There's a wait block, we need to wake the next pending</span></span><br><span class="line"><span class="comment">                   acquirer (exclusive or shared) */</span></span><br><span class="line">                WaitBlock = RtlpAcquireWaitBlockLock(SRWLock);</span><br><span class="line">                <span class="keyword">if</span> (WaitBlock != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    RtlpReleaseWaitBlockLockExclusive(SRWLock,</span><br><span class="line">                                                      WaitBlock);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* We released the lock */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* This is a fast path, we can simply clear the RTL_SRWLOCK_OWNED</span></span><br><span class="line"><span class="comment">                   bit. All other bits should be 0 now because this is a simple</span></span><br><span class="line"><span class="comment">                   exclusive lock and no one is waiting. */</span></span><br><span class="line"></span><br><span class="line">                ASSERT(!(CurrentValue &amp; ~RTL_SRWLOCK_OWNED));</span><br><span class="line"></span><br><span class="line">                NewValue = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (InterlockedCompareExchangePointer(&amp;SRWLock-&gt;Ptr,</span><br><span class="line">                                                      (PVOID)NewValue,</span><br><span class="line">                                                      (PVOID)CurrentValue) == (PVOID)CurrentValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* We released the lock */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* The RTL_SRWLOCK_SHARED bit must not be present now,</span></span><br><span class="line"><span class="comment">               not even in the contended case! */</span></span><br><span class="line">            RtlRaiseStatus(STATUS_RESOURCE_NOT_OWNED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        YieldProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的 RtlReleaseSRWLockShared 也与之类似，只是在 <code>SharedCount</code> 有一个判断，当 <code>SharedCount</code> 减小到 0 时才唤醒挂起链表中的线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line">NTAPI</span><br><span class="line">RtlReleaseSRWLockShared(IN OUT PRTL_SRWLOCK SRWLock)</span><br><span class="line">&#123;</span><br><span class="line">    LONG_PTR CurrentValue, NewValue;</span><br><span class="line">    PRTLP_SRWLOCK_WAITBLOCK WaitBlock;</span><br><span class="line">    BOOLEAN LastShared;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CurrentValue = *(<span class="keyword">volatile</span> LONG_PTR *)&amp;SRWLock-&gt;Ptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_SHARED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CurrentValue &amp; RTL_SRWLOCK_CONTENDED)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* There's a wait block, we need to wake a pending</span></span><br><span class="line"><span class="comment">                   exclusive acquirer if this is the last shared release */</span></span><br><span class="line">                WaitBlock = RtlpAcquireWaitBlockLock(SRWLock);</span><br><span class="line">                <span class="keyword">if</span> (WaitBlock != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    LastShared = (--WaitBlock-&gt;SharedCount == <span class="number">0</span>);        <span class="comment">// 这里比较特殊</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (LastShared)</span><br><span class="line">                        RtlpReleaseWaitBlockLockLastShared(SRWLock,</span><br><span class="line">                                                           WaitBlock);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        RtlpReleaseWaitBlockLock(SRWLock);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* We released the lock */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* This is a fast path, we can simply decrement the shared</span></span><br><span class="line"><span class="comment">                   count and store the pointer */</span></span><br><span class="line">                NewValue = CurrentValue &gt;&gt; RTL_SRWLOCK_BITS;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--NewValue != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    NewValue = (NewValue &lt;&lt; RTL_SRWLOCK_BITS) | RTL_SRWLOCK_SHARED | RTL_SRWLOCK_OWNED;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (InterlockedCompareExchangePointer(&amp;SRWLock-&gt;Ptr,</span><br><span class="line">                                                      (PVOID)NewValue,</span><br><span class="line">                                                      (PVOID)CurrentValue) == (PVOID)CurrentValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Successfully released the lock */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* The RTL_SRWLOCK_SHARED bit has to be present now,</span></span><br><span class="line"><span class="comment">               even in the contended case! */</span></span><br><span class="line">            RtlRaiseStatus(STATUS_RESOURCE_NOT_OWNED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        YieldProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Windows 的实现与 ReacOs 中有所不同，但是大体思路是一样的， 函数 RtlAcquireSRWLockExclusive 代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRWLockSpinCount 1024  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Busy_Lock       1   <span class="comment">// 已经有人获取了锁  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Wait_Lock       2   <span class="comment">// 有人等待锁  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Release_Lock    4   <span class="comment">// 说明已经有人释放一次锁  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mixed_Lock      8   <span class="comment">// 共享锁、独占锁并存 </span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SyncItem</span>  </span></span><br><span class="line"><span class="class">    &#123;</span>  </span><br><span class="line">        _SyncItem* back;  </span><br><span class="line">        _SyncItem* notify;  </span><br><span class="line">        _SyncItem* next;  </span><br><span class="line">        QWORD shareCount;  </span><br><span class="line">        DWORD flag;      </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">RtlAcquireSRWLockExclusive</span><span class="params">(<span class="keyword">volatile</span> PRTL_SRWLOCK *srwlock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __declspec( align( <span class="number">16</span> ) ) _SyncItem syn = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">  _RDI = (<span class="keyword">volatile</span> <span class="keyword">signed</span> __int64 *)srwlock;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( _interlockedbittestandset64(srwlock, <span class="number">0</span>i64) )    <span class="comment">// 之前锁已经被占用</span></span><br><span class="line">  &#123;</span><br><span class="line">    lockStatu = srwlock-&gt;ptr;    </span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( lockStatu &amp; Busy_Lock )     <span class="comment">// 锁已经被占用</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)RtlpWaitCouldDeadlock(a1, a2, a3, a4, v9) )</span><br><span class="line">          ZwTerminateProcess(<span class="number">-1</span>i64, <span class="number">3221225547</span>i64);</span><br><span class="line">        syn-&gt;shareCount = NtCurrentTeb()-&gt;ClientId.UniqueThread;</span><br><span class="line">        v3 = <span class="number">0</span>;</span><br><span class="line">        syn-&gt;flag = <span class="number">3</span>;</span><br><span class="line">        syn-&gt;next = null;</span><br><span class="line">        <span class="keyword">if</span> ( lockStatu &amp; Wait_Lock )    <span class="comment">// 有等待</span></span><br><span class="line">        &#123;</span><br><span class="line">          syn-&gt;notify = null;</span><br><span class="line">          syn-&gt;bala = <span class="number">-1</span>;</span><br><span class="line">          a1 = (<span class="keyword">volatile</span> <span class="keyword">signed</span> __int32 *)(<span class="keyword">unsigned</span> __int8)lockStatu;</span><br><span class="line">          syn-&gt;back = lockStatu &amp; <span class="number">0xFFFFFFFFFFFFFFF0</span>;  <span class="comment">//  获取等待链表头</span></span><br><span class="line">          newStatu= &amp;syn | lockStatu &amp; <span class="number">8</span> | <span class="number">7</span>; </span><br><span class="line">           v3 = ~((<span class="keyword">unsigned</span> __int8)lockStatu &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// 无等待</span></span><br><span class="line">        &#123;</span><br><span class="line">            syn-&gt;notify = &amp;syn;</span><br><span class="line">            <span class="keyword">if</span> ( (lockStatu &gt;&gt; <span class="number">4</span>) &gt; <span class="number">1</span> )    <span class="comment">//此时 Ptr 前几位保存的是 ShareCount，若有多个 shared 线程</span></span><br><span class="line">                newStatu = &amp;syn | Wait_Lock | Busy_Lock | Mixed_Lock;            </span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                newStatu = &amp;syn | Wait_Lock | Busy_Lock;</span><br><span class="line">          <span class="keyword">if</span> ( !(lockStatu &gt;&gt; <span class="number">4</span>) )    <span class="comment">// 如果没有共享，说明目前是一个 独占线程在占用</span></span><br><span class="line">             syn-&gt;bala = <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v8 = _InterlockedCompareExchange(srwlock-&gt;ptr, newStatu, lockStatu);   <span class="comment">// 将 ptr 设置成新值</span></span><br><span class="line">        <span class="keyword">if</span>( v8 == lockStatu )    <span class="comment">// 如果 ptr 被改变了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( v3 )</span><br><span class="line">                OptimizeSRWLockList(srwlock, newStatu);</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = SRWLockSpinCount; i&gt;<span class="number">0</span>; --i )  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="comment">// flag(bit1) can be reset by release-lock operation in other thread  </span></span><br><span class="line">                    <span class="keyword">if</span> ( !(syn.flag &amp; <span class="number">2</span>) )  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    _mm_pause();  </span><br><span class="line">                &#125;  </span><br><span class="line">            <span class="keyword">if</span>(interlockedbittestandreset(syn-&gt;flag ,<span class="number">1</span>)) <span class="comment">// 如果修改了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                    NtWaitForAlertByThreadId(srwlock,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span>( syn-&gt;flag &amp; <span class="number">4</span>  )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RtlBackoff(&amp;v15);  </span><br><span class="line">            lockStatu = (<span class="keyword">size_t</span>)pSRWLock-&gt;Ptr;  </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">// 锁在这个请求的过程中正好被释放了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将锁的状态修改为占用态</span></span><br><span class="line">        <span class="keyword">if</span> ( lockStatu == _InterlockedCompareExchange(srwlock, lockStatu+<span class="number">1</span>, lockStatu) )</span><br><span class="line">          <span class="keyword">return</span>;     <span class="comment">// 如果成功修改，直接返回</span></span><br><span class="line"></span><br><span class="line">        RtlBackoff(&amp;v15);</span><br><span class="line">        lockStatu = (<span class="keyword">size_t</span>)pSRWLock-&gt;Ptr;  </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说用于管理 MRDATA的 SRWLock 不会处于 MRDATA中，但是有些 SRWLock 却是在 MRDATA 解除保护之后才能获取到。这是一个很奇怪的设计，也许我们可以通过尝试修改 SRWLock 的相关数据来做一些事情。</p>
<p>首先随意选择一个调用 <code>LdrProtectMrdata</code> 的函数进行观察。这里选择的函数是 RtlDeleteGrowableFunctionTable , 这个函数会在 JIT 代码段被回收时调用。函数伪代码如下，为了直观删去了一些无关内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">RtlDeleteGrowableFunctionTable</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  </span><br><span class="line">  LdrProtectMrdata(<span class="number">0</span>i64);</span><br><span class="line">  <span class="keyword">if</span> ( qword_18017A370 )</span><br><span class="line">  &#123;</span><br><span class="line">    RtlAcquireSRWLockExclusive(&amp;LdrpMrdataLock);   <span class="comment">// RtlAcquireSRWLockExclusive 请求  LdrpMrdataLock</span></span><br><span class="line">    v3 = *(_DWORD *)LdrpMrdataHeapUnprotected;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)LdrpMrdataHeapUnprotected )</span><br><span class="line">      LdrpChangeMrdataHeapProtection(<span class="number">4</span>i64);</span><br><span class="line"></span><br><span class="line">    *(_DWORD *)LdrpMrdataHeapUnprotected = v3 + <span class="number">1</span>;</span><br><span class="line">    RtlReleaseSRWLockExclusive(&amp;LdrpMrdataLock);</span><br><span class="line">  &#125;</span><br><span class="line">  RtlAcquireSRWLockExclusive(&amp;RtlpDynamicFunctionTableLock);  <span class="comment">// RtlAcquireSRWLockExclusive 请求 RtlpDynamicFunctionTableLock</span></span><br><span class="line">  RtlAvlRemoveNode(&amp;RtlpDynamicFunctionTableTree, v1 + <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">  *v5 = v4;</span><br><span class="line">  *(_QWORD *)(v4 + <span class="number">8</span>) = v5;</span><br><span class="line">  RtlReleaseSRWLockExclusive(&amp;RtlpDynamicFunctionTableLock);</span><br><span class="line"></span><br><span class="line">  RtlFreeHeap(v6, <span class="number">0</span>i64, v1);</span><br><span class="line">  <span class="keyword">if</span> ( qword_18017A370 )</span><br><span class="line">  &#123;</span><br><span class="line">    RtlAcquireSRWLockExclusive(&amp;LdrpMrdataLock);       <span class="comment">// RtlAcquireSRWLockExclusive 请求 LdrpMrdataLock</span></span><br><span class="line">    v7 = *(_DWORD *)LdrpMrdataHeapUnprotected;</span><br><span class="line"></span><br><span class="line">    *(_DWORD *)LdrpMrdataHeapUnprotected = v7 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="number">1</span> )</span><br><span class="line">      LdrpChangeMrdataHeapProtection(<span class="number">2</span>i64);</span><br><span class="line">    RtlReleaseSRWLockExclusive(&amp;LdrpMrdataLock);</span><br><span class="line">  &#125;</span><br><span class="line">  LdrProtectMrdata(<span class="number">1</span>i64);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中可以看到，函数共请求了三次 <code>SRWLock</code>，三次操作均与 <code>.MRDATA</code> 相关。因此函数在开始和结束的位置分别调用 <code>LdrProtectMrdata(0)</code>、<code>LdrProtectMrdata(1)</code> 开关 <code>.MRDATA</code> 段的保护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LdrProtectMrdata( a1 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1 )</span><br><span class="line">    &#123;</span><br><span class="line">        LdrpChangeMrdataProtection(<span class="number">2u</span>);    <span class="comment">// ZwProtectVirtualMemory(-1,  LdrpMrdataBase,  LdrpMrdataSize  , 2, &amp;v2) </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LdrpChangeMrdataProtection(<span class="number">4u</span>);    <span class="comment">// ZwProtectVirtualMemory(-1,  LdrpMrdataBase,  LdrpMrdataSize  , 4, &amp;v4) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们将 <code>LdrpMrdataLock</code> 或者 <code>RtlpDynamicFunctionTableLock</code> 的标记位修改成 <code>RTL_SRWLOCK_SHARED | RTL_SRWLOCK_CONTENDED | RTL_SRWLOCK_OWNED</code>，那么根据上面对于 <code>SRWLock</code>的函数描述，相关的 <code>SRWLock</code> 将被认为已被占用而一直挂起新的请求。于是上面的函数在请求 <code>SRWLock</code> 时便会被挂起，其后的操作将不会继续执行（包括后来的<code>LdrProtectMrdata(1i64)</code>），而 <code>.MRDATA</code> 由于函数开始时的 <code>LdrProtectMrdata(0i64);</code> 操作将被设置为 0 ，从而关闭 <code>.MRDATA</code> 段的保护。</p>
<p>由此通过修改 <code>SRWLock</code> 破坏了线程调用的完整性，从而获得 <code>.MRDATA</code> 的操作权限。 </p>
<p>JIT 操作一般处于单独的线程中执行，不会影响 js 解析线程的执行，因此在获得 <code>.MRDATA</code> 的操作权限后，并不会中断 js 代码的继续执行。攻击者便可以使用任意地址写修改 bitmap 指针，从而绕过 CFG 保护</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种方法思路十分新颖，且操作简单，通过修改一位数据便可以绕过 CFG 保护。不仅如此，由于 <code>.MRDATA</code>  段中还包含了很多全局性的敏感对象，使用这种方法还有可能达到其他意想不到的效果</p>
<h2 id="Refenrence"><a href="#Refenrence" class="headerlink" title="Refenrence"></a>Refenrence</h2><ul>
<li><a href="http://alex-ionescu.com/publications/euskalhack/euskalhack2017-cfg.pdf" target="_blank" rel="noopener">Universally Bypass CFG Through Mutability abuse</a></li>
<li><a href="http://cdnnn.07net01.com/linux/2017/01/1791030.html" target="_blank" rel="noopener">用户模式下的线程同步 SRWLock剖析</a></li>
<li><a href="http://www.reactos.org/pipermail/ros-diffs/2006-August/013936.html" target="_blank" rel="noopener">http://www.reactos.org/pipermail/ros-diffs/2006-August/013936.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mohamoha.club/2017/12/23/Bypass_CFG_Through_MRDATA/" data-id="ckqyxnmbj0002hkuqw99qpyaa" class="article-share-link">Share</a>
      
        <a href="http://mohamoha.club/2017/12/23/Bypass_CFG_Through_MRDATA/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/27/Decrypt_Pyc/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Decrypt PYC
        
      </div>
    </a>
  
  
    <a href="/2017/12/05/Raspberry_Pi/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">RaspBerry Pi 折腾笔记</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/30/JavascriptInterface_once_more/">JavaScriptInterface Once More</a>
          </li>
        
          <li>
            <a href="/2021/04/30/IDEA/">后反序列化攻击调试中的IDE</a>
          </li>
        
          <li>
            <a href="/2020/08/16/chrome_dead_lock/">解决 Chrome 启动进程卡顿问题</a>
          </li>
        
          <li>
            <a href="/2019/09/14/Link_file_and_sdcard/">Link File and Sdcard in Android</a>
          </li>
        
          <li>
            <a href="/2019/01/06/AST_Fuzzer/">AST Fuzz —— a New Kind of Fuzzer</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget tag">
    <h3 class="title">Site Links</h3>
    <ul class="entry">
    <li><a href="http://5alt.me" title="5alt">5alt's Blog</a></li>
    </ul>
</div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 mohaplus<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="https://github.com" class="mobile-nav-link">github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'mohamoha';
  
  var disqus_url = 'http://mohamoha.club/2017/12/23/Bypass_CFG_Through_MRDATA/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>